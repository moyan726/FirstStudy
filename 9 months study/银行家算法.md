# 操作系统：银行家算法题目与解题笔记

## 一、灵魂三问：什么是银行家算法？ 是怎么产生的？为了解决什么问题？

### 1. 它是怎么产生的？ (历史渊源)

银行家算法（Banker's Algorithm）是由计算机科学界的泰斗 **艾兹格·迪杰斯特拉 (Edsger W. Dijkstra)** 在 **1965年** 提出的。

- **背景：** 当时 Dijkstra 正在设计著名的 **THE 多道程序系统 (THE Multiprogramming System)**。这是最早支持并发（多个程序同时运行）的操作系统之一。
- **问题：** 在多道程序环境下，多个进程会争夺有限的系统资源（如磁带机、内存块）。如果没有合理的分配策略，很容易出现**“死锁” (Deadlock)**——即所有进程都在等待其他进程释放资源，导致谁也动不了，系统卡死。
- **灵感：** Dijkstra 借用了现实生活中**银行借贷**的逻辑来解决这个问题。银行在放贷时，必须保证手里留有足够的现金（流动资金），以便能满足某个大客户的提款需求，从而避免银行破产（类似系统崩溃）。

因此，这个算法是为了**避免死锁 (Deadlock Avoidance)** 而诞生的。

------



### 2. 什么是银行家算法？

简单来说，它是操作系统在分配资源前的一种**“预判”机制**。

核心思想：当一个进程向系统申请资源时，操作系统不会马上给它，而是先进行一次**“模拟分配”**（试探），然后计算一下：“如果我把这笔资源借给你，剩下的资源还能不能让所有人都顺利完工？”

- **如果能（处于安全状态）：** 批准请求，真的分配资源。
- **如果不能（处于不安全状态）：** 拒绝或推迟请求，让进程等待。

#### 形象的例子（银行比喻）：

想象你是**银行家（操作系统）**，手里的现金是**资源**，客户是**进程**。

1. **规则：** 每个客户在开户时，必须声明自己最多需要借多少钱（**Max 矩阵**）。
2. **现状：** 客户已经借走了一部分钱（**Allocation**），还需要借一部分（**Need**）才能做完生意还钱。
3. **场景：**
   - 客户 A 跑来说：“再借我 10 万。”
   - 你看了看金库，如果借给他 10 万，你手里只剩 1 万了。
   - 但是，此时客户 B 需要 5 万才能完工还钱，客户 C 需要 3 万才能完工还钱。
   - **你的判断：** “不行，借给 A 之后，我手里的 1 万块既满足不了 B，也满足不了 C。一旦 B 和 C 都要钱，我就破产了（死锁）。”
   - **结果：** 此时处于**不安全状态**，拒绝 A 的请求。

------



### 3. 两个关键概念

在银行家算法中，最重要的两个状态判定：

1. 安全状态 (Safe State)：

   系统能找到一个安全序列（如 P1 -> P3 -> P2...）。按照这个顺序，系统先满足 P1，等 P1 用完释放资源后，回收的资源加上原本剩余的资源，足够满足 P3，以此类推。只要能找到至少一个这样的序列，系统就是安全的。

2. 不安全状态 (Unsafe State)：

   系统找不到任何一个安全序列。

   - *注意：不安全状态 $\neq$ 必然死锁。*
   - 不安全状态只是意味着**有可能**发生死锁。银行家算法非常谨慎，只要有风险，它就认为是不安全的。

------



### 4. 为什么现代操作系统很少用它？

虽然银行家算法理论上非常完美，但在实际的 Windows、Linux 或 macOS 中，很少直接使用它来管理资源，原因如下：

1. **太耗时：** 每次进程申请资源都要跑一遍复杂的算法（就是你题目里做的那些矩阵运算），系统开销太大，不仅慢而且浪费 CPU。
2. **无法预知 Max：** 在现实中，大多数程序（进程）在运行前根本不知道自己到底需要多少资源（比如浏览器打开多少个标签页取决于用户，无法预知最大需求）。
3. **资源数量动态变化：** 现代系统中，可用资源的数量（如空闲内存）是动态波动的，而银行家算法假设资源总数是固定的。

**总结：** 银行家算法是操作系统理论中的经典，它教会了我们如何通过**预先检查**来**避免危机**，虽然实战中用得少，但在理解死锁原理和算法思维上非常有价值。





## 二、 银行家算法例题



![image-20251128190208154](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251128190208154.png)

某系统有 A、B、C、D 四类资源可供五个进程 P1、P2、P3、P4、P5 共享。

系统对这四类资源的拥有总量为：

- **A类：3个**
- **B类：14个**
- **C类：12个**
- **D类：12个**

进程对资源的需求和分配情况如下表所示：

| **进程** | **已占有资源 (Allocation)A B C D** | **最大需求数 (Max)A B C D** |
| -------- | ---------------------------------- | --------------------------- |
| **P1**   | 0 0 1 2                            | 0 0 1 2                     |
| **P2**   | 1 0 0 0                            | 1 7 5 0                     |
| **P3**   | 1 3 5 4                            | 2 3 5 6                     |
| **P4**   | 0 6 3 2                            | 0 6 5 2                     |
| **P5**   | 0 0 1 4                            | 0 6 5 6                     |

**按银行家算法回答下列问题：**

1. 现在系统中的各类资源还**剩余多少**？（4分）
2. 现在系统是否处于**安全状态**？为什么？（6分）
3. 如果现在进程 P2 提出需要 A类资源0个、B类资源4个、C类资源2个和D类资源0个，系统能否去满足它的请求？请说明原因。（6分）

------



## 三、 解题笔记

### (1) 解：各类资源剩余多少？

**计算公式：** $Available = Total - \sum Allocation$

1. **统计已占有资源 (Allocated):**
   - **A:** $1 (P2) + 1 (P3) = 2$
   - **B:** $3 (P3) + 6 (P4) = 9$
   - **C:** $1 (P1) + 5 (P3) + 3 (P4) + 1 (P5) = 10$
   - **D:** $2 (P1) + 4 (P3) + 2 (P4) + 4 (P5) = 12$
2. **计算剩余资源 (Available):**
   - **A:** $3 - 2 = \mathbf{1}$
   - **B:** $14 - 9 = \mathbf{5}$
   - **C:** $12 - 10 = \mathbf{2}$
   - **D:** $12 - 12 = \mathbf{0}$

**答：系统目前可用资源向量 Available = (1, 5, 2, 0)**

------



### (2) 解：系统是否处于安全状态？

第一步：完善矩阵，计算需求矩阵 (Need)

**计算公式：$Need = Max - Allocation$**

| **进程** | **Max (最大需求)** | **Allocation (已分配)** | **Need (还需要)** |
| -------- | ------------------ | ----------------------- | ----------------- |
| **P1**   | 0 0 1 2            | 0 0 1 2                 | **0 0 0 0**       |
| **P2**   | 1 7 5 0            | 1 0 0 0                 | **0 7 5 0**       |
| **P3**   | 2 3 5 6            | 1 3 5 4                 | **1 0 0 2**       |
| **P4**   | 0 6 5 2            | 0 6 3 2                 | **0 0 2 0**       |
| **P5**   | 0 6 5 6            | 0 0 1 4                 | **0 6 4 2**       |

**初始可用资源 (Available): (1, 5, 2, 0)**

> 我们需要比较的是：**进程还需要的资源 (Need)** vs **系统当前手里的资源 (Available)**。
>
> **核心判断规则**是：只有当 **$Need \le Available$** 时，这个进程才能被选中。
>
> 虽然 **P1** 和 **P4** 在第一轮都符合条件，但在解题或编写算法时，我们通常遵循以下两个习惯：
>
> 1. **顺序优先原则：** 算法通常从 P1 到 P5 顺序扫描。因为 P1 是第一个被扫描到且符合条件的，所以直接选中它，把它加入安全序列，然后回收它的资源，更新 Available，再进行下一轮。
> 2. **"零需求"特性：** P1 的 Need 是 $(0, 0, 0, 0)$。这意味着 P1 不需要向系统借任何东西就能运行结束。选中它没有任何风险，还能立刻回收它占用的资源（Allocation: 0 0 1 2），让 Available 变大，从而更容易满足后面那些“胃口大”的进程（如 P2）。

**第二步：安全性检测表**

| **进程** | **Work (可用资源)** | **Need (需求)** | **Allocation (已占有)** | **Work + Allocation (回收后可用)** | **是否满足 (T/F)** |
| -------- | ------------------- | --------------- | ----------------------- | ---------------------------------- | ------------------ |
| **P1**   | 1 5 2 0             | 0 0 0 0         | 0 0 1 2                 | **1 5 3 2**                        | **T**              |
| **P4**   | 1 5 3 2             | 0 0 2 0         | 0 6 3 2                 | **1 11 6 4**                       | **T**              |
| **P2**   | 1 11 6 4            | 0 7 5 0         | 1 0 0 0                 | **2 11 6 4**                       | **T**              |
| **P3**   | 2 11 6 4            | 1 0 0 2         | 1 3 5 4                 | **3 14 11 8**                      | **T**              |
| **P5**   | 3 14 11 8           | 0 6 4 2         | 0 0 1 4                 | **3 14 12 12**                     | **T**              |

> *注：最后一行的 Work+Allocation 结果 (3, 14, 12, 12) 应等于资源总数。*

**结论：**可以找到一个安全序列： P1 $\rightarrow$ P4 $\rightarrow$ P2 $\rightarrow$ P3 $\rightarrow$ P5    所以，现在系统处于安全状态。



###  (3) 解：P2 请求资源的分配判断

如果现在进程 P2 提出需要 A类资源0个、B类资源4个、C类资源2个和D类资源0个，系统能否去满足它的请求？请说明原因。

#### 1. 初始数据检查

- **P2 的请求向量 Request ($R$)**: $(0, 4, 2, 0)$
- **P2 的需求向量 Need**: $(0, 7, 5, 0)$  *(来自第二问计算结果)*
- **当前系统可用资源 Available ($Av$)**: $(1, 5, 2, 0)$ *(来自第一问计算结果)*



#### 2. 银行家算法检查步骤

第一步：检查请求是否超过需求

$$Request \le Need$$    判断   $$(0, 4, 2, 0) \le (0, 7, 5, 0)$$  --->  结果： 成立。

> 银行家算法的一个核心前提是：**进程在开始运行前，必须声明自己对每类资源的最大需求量 ($Max$)。**这是一个**硬性契约**。
>
> **性质：** **非法请求**。  **潜台词：** “你骗人！你说过没要这么多的。”

第二步：检查请求是否超过系统可用资源

$$Request \le Available$$  判断   $$(0, 4, 2, 0) \le (1, 5, 2, 0)$$     ---->   结果： 成立。

> **性质：** **合法但暂时无法满足**。**潜台词：** “你要的是合理的，但我现在手头紧，没有现货。”

#### 3. 试探性分配并更新系统状态

假设系统分配资源给 P2，更新后的数据如下：

- 新的可用资源 ($Av_{new} = Av - R$):

  $$(1, 5, 2, 0) - (0, 4, 2, 0) = \mathbf{(1, 1, 0, 0)}$$

- P2 的新需求 ($Need_{new} = Need - R$):

  $$(0, 7, 5, 0) - (0, 4, 2, 0) = \mathbf{(0, 3, 3, 0)}$$

- P2 的新占有量 ($Allocation_{new} = Allocation + R$):

  $$(1, 0, 0, 0) + (0, 4, 2, 0) = \mathbf{(1, 4, 2, 0)}$$

------



#### 4. 安全性检测 (补全部分)

目的： 在更新后的状态下，检查是否存在一个安全序列。

当前 Available (Work) 向量： $(1, 1, 0, 0)$

| **进程** | **Work (可用)** | **Need (还需)** | **Allocation (已占)** | **Work+Allocation (回收后)** | **是否满足(Finish)** |
| -------- | --------------- | --------------- | --------------------- | ---------------------------- | -------------------- |
| **P1**   | 1 1 0 0         | 0 0 0 0         | 0 0 1 2               | **1 1 1 2**                  | **True**             |
| **P3**   | 1 1 1 2         | 1 0 0 2         | 1 3 5 4               | **2 4 6 6**                  | **True**             |
| **P4**   | 2 4 6 6         | 0 0 2 0         | 0 6 3 2               | **2 10 9 8**                 | **True**             |
| **P2**   | 2 10 9 8        | 0 3 3 0         | 1 4 2 0               | **3 14 11 8**                | **True**             |
| **P5**   | 3 14 11 8       | 0 6 4 2         | 0 0 1 4               | **3 14 12 12**               | **True**             |

> **注意推导过程中的逻辑：**
>
> 1. **P1** 需求为0，直接满足。Work 变为 (1,1,1,2)。
> 2. 此时检查 P4 (需C=2) 和 P2 (需B=3) 均无法满足（因为 Work 中 C=1, B=1）。
> 3. 检查 **P3**，需求 (1,0,0,2) $\le$ Work (1,1,1,2)，满足。Work 更新为 (2,4,6,6)。
> 4. 此时资源充足，**P4** 需求 (0,0,2,0) 满足。Work 更新为 (2,10,9,8)。
> 5. **P2** 需求 (0,3,3,0) 满足。Work 更新为 (3,14,11,8)。
> 6. 最后 **P5** 满足。



#### 5. 结论

可以找到一个安全序列（例如：$P1 \rightarrow P3 \rightarrow P4 \rightarrow P2 \rightarrow P5$）。

**答：系统可以满足 P2 的请求。因为试探性分配后，系统仍处于安全状态，存在安全序列。**